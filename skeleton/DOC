EECS 343 Project 2 - 2014 Fall

Kernel Memory Allocation

Authors: Jin Sun (jsy833), Yuchao Zhou (yzr736)

Algorithms: Implement resource map (kma_rm), buddy system (kma_bud) and simple power of 2 free list (kma_p2fl).

Implementation Summary:
Resource Map:

P2FL:

Buddy System:

Algorithm comparison:


When the operating system has to allocate and manage all of the given physical memory, it will allocate it to either user-level processes or to the kernel. Memory allocated to the kernel will have its own memory manager called the kernel memory allocator (KMA), which will use different mechanisms because memory requests made to the kernel will most likely be a lot smaller than a page size.
There are different algorithms in handling kernel memory, and we¡¯ve implemented the following: Power-of-two Free List, Buddy System, Resource Map, and McKusick-Karels. In this report, we will compare the performance of each algorithm, based on how many pages were requested to satisfy the amount of memory requested, as well as the time it took to allocate these memories.

Data collection and comparison

After implementing the four algorithms, we timed how long it took
each of them to run trace 5 as well as their resource utilization.

We collected the times with a simple time -p command and took
the real elapsed time it took for the trace to run, in seconds.

For resource utilization, for each malloc request, we calculated
the total allocated bytes and divided by the total page bytes that
were used at the time. Then we averaged all of these values for
all of the malloc calls.

Here is the data:

Algorithm 	Time(s) 	Utilization
P2FL 		0.58		0.58
BUD 		0.62		0.65
RM 			85.68 		0.49
MCK2 		0.83 		0.07

BUD takes a little longer than P2FL because it does extra work 
making recursive calls to break up larger buffers into smaller
ones. This also results in nigher utilization because now the
pages can be used for buffers of different size so there is
a diversity of buffer sizes that can be used for a single page

RM is really slow because we implemented it with singly-linked
lists so a lot of time was used to traverse these lists.

MCK2 has really bad utilization because the nature of its 
algorithm causes a lot of fragmentation.
